--
-- Minila interpreter
--

--
-- - Function interpret interprets a given Minila program,
--   returning the environment made by executing the progam.
-- - Function eval takes a Minila program and an environment
--   and executes the program under the environment, returning
--   the environment updated by executing the progam.
-- - Function evalAssign executes an assignment under a given
--   environment.
-- - Function evalIf executes an If statement under a given
--   environment.
-- - Function evalWhile executes a While statement under a given
--   environment.
-- - Function evalExp computes an expression under a given
--   environment, returning the result (a natural number).
--
mod! INTERPRET {
  pr(STM)
  pr(ENV)
  op interpret : Stm -> Env&Err .
  op eval : Stm Env&Err -> Env&Err .
  op evalAssign : Var Nat&Err Env&Err -> Env&Err .
  op evalIf : Nat&Err Stm Stm Env&Err -> Env&Err .
  op evalWhile : Exp Stm Env&Err -> Env&Err .
  op evalExp : Exp Env&Err -> Nat&Err .
  vars E E1 E2 : Exp .
  vars S S1 S2 : Stm .
  var V : Var .
  var EV : Env .
  var N : Nat .
  -- interpret
  -- eval
  eq eval(estm, EV) = EV .
  eq eval(V := E ; , EV) = evalAssign(V, evalExp(E, EV), EV) .
  eq eval(if E {S1} else {S2}, EV) = evalIf(evalExp(E, EV), S1, S2, EV) .
  eq eval(while E {S}, EV) = evalWhile(E, S, EV) .
  eq eval(S1 S2, EV) = eval(S2, eval(S1, EV)) .
  eq eval(for V E1 E2 {S}, EV) = eval(
    V := E1 ;
    while V < E2 || V === E2 {
      S
      V := V + s(1) ;
    }, EV) .

  -- evalAssign
  -- eq evalAssign(V, N, errEnv) = errEnv .
  -- eq evalAssign(V, errNat, EV) = errEnv .
  -- update: Env&Err Var Nat&Err -> Env&Err .
  eq evalAssign(V, N, EV) = update((V,N) | EV, V, N) .

  -- evalIf
  -- eq evalIf(E, S1, S2, errEnv) = errEnv .
  eq evalIf(0, S1, S2, EV) = eval(S2, EV) .
  eq evalIf(1, S1, S2, EV) = eval(S1, EV) .

  -- evalWhile
  eq evalWhile(E, S, errEnv) = errEnv .
  eq evalWhile(E, S, EV) = EV .
  eq evalWhile(E, S, EV)
    = if evalExp(E, EV) == 0
      then { EV }
      else { evaiWhile(E, S, eval(S, EV)) } .

  -- evalExp
  eq evalExp(n(N) ,EV) = N .
  eq evalExp(V ,EV) = lookup(EV, V) .
  eq evalExp(E1 + E2 ,EV) = evalExp(E1, EV) + evalExp(E2, EV) .
  eq evalExp(E1 === E2 ,EV) =
    if evalExp(E1, EV) == errNat or evalExp(E2, EV)
    then {errNat}
    else {
      if evalExp(E1, EV) == evalExp(E2, EV)
      then {1}
      else {0}
    } .
  eq evalExp(E1 * E2 ,EV) = evalExp(E1, EV) * evalExp(E2, EV) .
  eq evalExp(E1 && E2 ,EV) = evalExp(E1, EV) && evalExp(E2, EV) .
}

eof

open INTERPRET .
  ops x y z tmp : -> Var .

  op p1 : -> Stm .
  eq p1 = x := n(1) ;
          y := n(1) ;
          while y < n(10) || y === n(10) {
            x := x * y ;
            y := y + n(1) ;
          } .
  red interpret(p1) .

  op p2 : -> Stm .
  eq p2 = x := n(1) ;
          for y n(1) n(10) {
            x := y * x ;
          } .
  red interpret(p2) .

  op p3 : -> Stm .
  eq p3 = x := n(24) ;
          y := n(30) ;
          while y =!= n(0) {
            z := x % y ;
            x := y ;
            y := z ;
          } .
  red interpret(p3) .

  op p4 : -> Stm .
  eq p4 = x := n(20000000000000000) ;
          y := n(0) ;
          z := x ;
          while y =!= z {
            if ((z - y) % n(2)) === n(0) {
              tmp := y + (z - y) / n(2) ;
            } else {
              tmp := y + ((z - y) / n(2)) + n(1) ;
            }
            if tmp * tmp > x {
              z := tmp - n(1) ;
            } else {
              y := tmp ;
            }
          } .
  red interpret(p4) .
close
