## Ex 1
#### GCD
- 用語
  - op : operation
  - eq : equation
  - red : reduce 「計算せよ」という命令
  - rem : remainder 剰余を表している
- 解説
  - ユークリッドの互除法を用いて最大公約数を計算している。
  - 1つめの方程式（第2引数が0の場合）は、第1引数を返すと定義し、
  - 2つめの方程式（第2引数が0以外の場合）は gcd(第2引数, 第1引数を第2引数で割ったときの剰余) と再帰的に実行して返すと定義している。

#### Factorial
- 用語
  - p : 1つ前の数字
- 解説
  - 再帰的な定義を用いて階乗を計算している
  - 1つめの方程式（引数が0の場合）を1として定義している
  - 2つめの方程式（第2引数が0以外の場合）を、引数と引数-1の乗算であると定義している

#### Odd-Even Divide and Conquer Factorial
- 用語
  - sd : 差の絶対値
- 概要
  - 10000 を64bit OSでも計算できる。並列計算に向いている実装。
- 解説
  - 演算子 cond: 「真偽値, 自然数, 自然数」と引数にとって自然数を返す
    - 第1引数の真偽値が true の場合は第2引数である自然数を返すと定義
    - 第2引数の真偽値が false の場合は第3引数である自然数を返すと定義
  - 演算子 g: 「自然数, 自然数」と引数にとって自然数を返す
    - 第1引数のほうが大きい場合は g(第1引数, 2 * 第2引数) * g(第1引数と第2引数の差の絶対値, 2 * 第2引数) を返すと定義
    - それ以外の場合は、第1引数自体を返すと定義
  - 演算子 odec-fact: 自然数を引数にとって自然数を返すと定義
    - 引数が0の場合は1を返すと定義
    - それ以外の場合は g(引数, 1) を返すと定義

#### Fibonacci
- 解説
  - 演算子 fib: 自然数を引数にして自然数を返す
    - 引数が0の場合、0 を返すと定義
    - それ以外の場合、sfib(引数 - 1) を返すと定義
  - 演算子 sfib: 自然数を引数にして自然数を返す
    - 引数が0の場合、1 を返すと定義
    - それ以外の場合、fib(引数) + fib(引数 - 1) を返すと定義

#### Ackerman
- 概要
  - primitive recursive 関数に入っていないが、計算できる
  - ただし、引数の数値が大きくなると計算できなくなることで有名
- 解説
  - 1つめの等式（第1引数が0の場合）は第2引数に1を足すと定義している
  - 2つめの等式（第2引数が0の場合）は ack(第1引数から1を引いた数, 1) と再帰的に定義している
  - 3つめの等式（それ以外の場合）は ack(第1引数から1を引いた数, ack(第1引数, 第2引数から1を引いた数)) と再帰的に定義している

## Ex 2
#### fact(5) の計算過程の説明
```
fact(5) = 5 * fact(4) = 5 * 24 = 120
fact(4) = 4 * fact(3) = 4 * 6 = 24
fact(3) = 3 * fact(2) = 3 * 2 = 6
fact(2) = 2 * fact(1) = 2 * 1 = 2
fact(1) = 1 * fact(0) = 1 * 1 = 1
fact(0) = 1
```

## Ex 3
#### oedc-fact(5) の計算過程の説明
```
oedc-fact(5)
= g(5, 1)
= g(5, 2 * 1) * g(|5-1|, 2 * 1)
= g(5, 2) * g(4, 2)
= (g(5, 2 * 2) * g(|5-2|, 2 * 2)) * (g(4, 2 * 2) * g(|4-2|, 2 * 2))
= (g(5, 4) * g(3, 4)) * (g(4, 4) * g(2, 4))
= ((g(5, 2 * 4) * g(|5-4|, 2 * 4)) * 3) * (4 * 2)
= ((5 * 1) * 3) * (4 * 2)
= 120
```

## Ex 4
* 再帰的な呼び出し方に階乗と大きな違いはないが、階乗では 0! = 1 と定義されていたことに注意を要する
* sumf と oedc を同じ open, close 内に置いて、同じ引数での計算結果を == で比較したときに true となることを確かめている

## Ex 5
* 補助関数を2段階に用いて ext-fib-3(NzX) には最小でも1が渡ってくるようにして、NzNatのソートであることを保証している。

## Ex 6
* fact関数を再帰的に定義するのは同じ
* 引数を _ で表す
* 演算子の優先順位を明示するには (p NzX)! のようにカッコでくくってあげるとよい

## Ex 7
* if, then, else を引数3つの演算子として定義する
